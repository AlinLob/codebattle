#![allow(warnings)]

use libc::c_int;
use serde::Serialize;
use serde_with::{DurationNanoSeconds, serde_as};
use std::{
    collections::HashMap,
    fs::File,
    io::{self, Read},
    os::fd::{AsRawFd, FromRawFd, OwnedFd},
    process::exit,
    time::{self, Duration},
};

mod solution;

#[serde_as]
#[derive(Serialize, Debug)]
struct Result<T> {
    #[serde(rename = "type")]
    typ: String,
    value: T,
    #[serde_as(as = "DurationNanoSeconds")]
    execution_time: Duration,
    #[serde(skip_serializing_if = "String::is_empty")]
    output: String,
}

fn pipe() -> std::io::Result<(OwnedFd, OwnedFd)> {
    let mut fds: [c_int; 2] = [0; 2];
    let res = unsafe { libc::pipe(fds.as_mut_ptr()) };
    if res != 0 {
        return Err(io::Error::new(io::ErrorKind::Other, "create pipe"));
    }
    let read = unsafe { OwnedFd::from_raw_fd(fds[0]) };
    let write = unsafe { OwnedFd::from_raw_fd(fds[1]) };
    Ok((read, write))
}

fn main() {
    <%= for %{arguments: arguments} <- checks do %>
      <%= for %{defining: defining, value: value} <- arguments.info do %>
        let <%= defining %> = <%= value %>;
      <% end %>

      let (reader_, writer_) = match pipe() {
          Ok((r, w)) => (Some(r), Some(w)),
          Err(_) => (None, None),
      };
      let stdout_ = unsafe { libc::dup(io::stdout().as_raw_fd()) };

      if let Some(w) = writer_ {
          unsafe {
              let res = libc::dup2(w.as_raw_fd(), io::stdout().as_raw_fd());
              if res < 0 {
                  println!("hueta");
              }
          }
      };

      let start_ = time::Instant::now();
      let mut result_ = Result {
          typ: String::from("result"),
          value: solution::solution(<%= arguments.expression %>),
          execution_time: start_.elapsed(),
          output: String::new(),
      };

      if let Some(r) = reader_ {
          unsafe {
              libc::close(io::stdout().as_raw_fd());
              let _ = File::from_raw_fd(r.as_raw_fd()).read_to_string(&mut result_.output);
          }
      };

      if let Err(_) = serde_json::to_writer(unsafe { File::from_raw_fd(stdout_) }, &result_) {
          println!("Encoding error");
          exit(0);
      }
    <% end %>
}
